= VN-Suit
Voided Name
v1.0, 2025-12-15
:source-highlighter: rouge
// What a jank pointless pain github inflicts on all of us just because they don't conform to the asciidoc spec... thx: https://github.com/orgs/community/discussions/106933#discussioncomment-14246791 for the fix
ifdef::env-github[]
:MERMAID: source, mermaid
endif::[]
ifndef::env-github[]
:MERMAID: mermaid
endif::[]

.Main Project Goals
1. Improve my skill-set and learn more about gpu based programming.
2. Create a general fw for fun projects.
- This means that it must be rather sort of flexible

.Sub Project Ideas
- VTTRPG (virtual table top rpg system) - see link:vn-vttrpg/readme.asciidoc[vn-vttrpg/readme.asciidoc]
- Platformer like Hollow Knight
- Automation Game like Factorio / Shapez
- Knowledge Manager

== Project Structure

The VN-Suit workspace is organized into several interconnected crates that provide a flexible framework for building different applications while sharing common functionality.

.Workspace Architecture & Interconnections
[{MERMAID}]
----
graph TD
    subgraph RootWorkspace [vn-suit workspace]
        Root[vn-suit root]
        
        subgraph Core [Core Framework Crates]
            vn-ui
            vn-scene
            vn-ui-animation
            vn-ui-animation-macros
            vn-utils
            vn-ecs
            vn-wgpu-window

            vn-ui --> vn-scene
            vn-ui --> vn-ui-animation
            vn-ui --> vn-ui-animation-macros
            vn-ui --> vn-utils

            vn-wgpu-window --> vn-scene
            vn-wgpu-window --> vn-utils

            vn-scene --> vn-ui-animation
            vn-scene --> vn-ui-animation-macros

            vn-ui-animation --> vn-utils
        end
    end
    
    Root --> Core
----

This structure allows the framework to be shared by different applications.

[NOTE]
====
VTTRPG related packages and assets are located in their own workspace in the `vn-vttrpg` directory.
For more details, see link:vn-vttrpg/readme.asciidoc[vn-vttrpg/readme.asciidoc].
====



== Architecture & Design Decisions

The VN-Suit is designed with several core principles to ensure flexibility and portability:

. **Crate-based Modularization**: The project is split into many small, focused crates (see link:vn-utils/readme.asciidoc[vn-utils]). This promotes clean boundaries and allows for reusing only specific parts of the framework if needed.
. **Platform Abstraction via Traits**: Platform-specific functionality (like file loading) is abstracted through traits. This allows the core logic to remain platform-agnostic while launchers (Native vs Web) provide the concrete implementation. (See link:vn-wgpu-window/readme.asciidoc[vn-wgpu-window])
. **Data-Oriented Scene Graph**: link:vn-scene/readme.asciidoc[`vn-scene`] defines the "what" to render as plain data structures, while link:vn-wgpu-window/readme.asciidoc[`vn-wgpu-window`] implements the "how" using WGPU.
. **Cached UI Layout**: The link:vn-ui/readme.asciidoc[UI system] uses a layout cache to avoid redundant calculations, ensuring high performance even with complex UI trees.
. **Reactive Animation System**: link:vn-ui-animation/readme.asciidoc[Animations] are integrated into the UI properties, allowing for smooth transitions by simply interpolating values over time. (See also link:vn-ui-animation-macros/readme.asciidoc[vn-ui-animation-macros])
. **Entity Component System**: link:vn-ecs/readme.asciidoc[ECS] is a modular approach to model entities as a composition of multiple components. This differs from the traditional class hierarchy based one in that an entity, typically just some id, has no bias or opinion on what it is and its role and functionality within the "world" can be freely changed and modified simply by adding or removing components from it. A typical example is NPC or even PC capabilities, such as ranged vs melee attacks typically requiring individualised types that represent these and then their combination. Add a magic type, maybe some other and it explodes in combinatorical complexity.

== Things I still need to do

.Todo List for the UI FW
- [x] Primitive Rendering
- [x] Text Rendering: Support for glyph instancing.
- [x] Layout / Drawing Flow
- [x] Scene Rendering
- [x] Animation: Support for interpolatable properties.
- [ ] Optional: Anti Aliasing
- [ ] Text-Atlas: Currently I render one texture per character per font per font_size used. Using a single Atlas would allow me to avoid most of the memory throughput overhead. (Instancing is implemented, but Atlas is still missing)
- [x] Text Glyphs should be rendered at certain breakpoints like 8pt, 16pt, 32pt etc. When drawing a glyph we should pick an appropriate one and then rescale it via sampling on the gpu. (We would have to recreate every glyph / atlas when font_size is animated for every frame)
- [ ] Rich Text. Color, Font, Size, Clickable, Hoverable, (embedded ui elements?)
- [ ] Web and Native colors don't match. One of them does not compensate for sRGB correctly.
- [ ] Audio Engine
- [x] Resource / File loading (Web vs Native)

.General Framework TODOs
- [ ] Improved Input System: Better handling of multi-key combos and gamepad support.
- [ ] Localization Support: Framework-level support for translated strings.
- [ ] Documentation: Move from basic READMEs to comprehensive documentation.
- [ ] Testing: Implement automated UI and rendering tests.
- [ ] ECS: WIP