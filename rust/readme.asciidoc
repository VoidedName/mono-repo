= VN-Suit
Voided Name
v1.0, 2025-12-15
:source-highlighter: rouge

.Main Project Goals
1. Improve my skill-set and learn more about gpu based programming.
2. Create a general fw for fun projects.
- This means that it must be rather sort of flexible

.Sub Project Ideas
- VTTRPG (virtual table top rpg system) - see link:vn-vttrpg/readme.asciidoc[vn-vttrpg/readme.asciidoc]
- Platformer like Hollow Knight
- Automation Game like Factorio / Shapez
- Knowledge Manager

== Project Structure

The VN-Suit workspace is organized into several interconnected crates that provide a flexible framework for building different applications while sharing common functionality.

.Workspace Architecture & Interconnections
[mermaid]
----
graph TD
    subgraph RootWorkspace [vn-suit workspace]
        Root[vn-suit root]
        
        subgraph Core [Core Framework Crates]
            vn-ui
            vn-scene
            vn-ui-animation
            vn-ui-animation-macros
            vn-utils
            vn-wgpu-window

            vn-ui --> vn-scene
            vn-ui --> vn-ui-animation
            vn-ui --> vn-ui-animation-macros
            vn-ui --> vn-utils

            vn-wgpu-window --> vn-scene
            vn-wgpu-window --> vn-utils

            vn-scene --> vn-ui-animation
            vn-scene --> vn-ui-animation-macros

            vn-ui-animation --> vn-utils
        end
    end
    
    Root --> Core
----

This structure allows the framework to be shared by different applications.

[NOTE]
====
VTTRPG related packages and assets are located in their own workspace in the `vn-vttrpg` directory.
For more details, see link:vn-vttrpg/readme.asciidoc[vn-vttrpg/readme.asciidoc].
====



== Architecture & Design Decisions

The VN-Suit is designed with several core principles to ensure flexibility and portability:

. **Crate-based Modularization**: The project is split into many small, focused crates (see link:vn-utils/readme.asciidoc[vn-utils]). This promotes clean boundaries and allows for reusing only specific parts of the framework if needed.
. **Platform Abstraction via Traits**: Platform-specific functionality (like file loading) is abstracted through traits. This allows the core logic to remain platform-agnostic while launchers (Native vs Web) provide the concrete implementation. (See link:vn-wgpu-window/readme.asciidoc[vn-wgpu-window])
. **Data-Oriented Scene Graph**: link:vn-scene/readme.asciidoc[`vn-scene`] defines the "what" to render as plain data structures, while link:vn-wgpu-window/readme.asciidoc[`vn-wgpu-window`] implements the "how" using WGPU.
. **Cached UI Layout**: The link:vn-ui/readme.asciidoc[UI system] uses a layout cache to avoid redundant calculations, ensuring high performance even with complex UI trees.
. **Reactive Animation System**: link:vn-ui-animation/readme.asciidoc[Animations] are integrated into the UI properties, allowing for smooth transitions by simply interpolating values over time. (See also link:vn-ui-animation-macros/readme.asciidoc[vn-ui-animation-macros])

== Things I still need to do

.Todo List for the UI FW
- [x] Primitive Rendering
- [x] Text Rendering: Support for glyph instancing.
- [x] Layout / Drawing Flow
- [x] Scene Rendering
- [x] Animation: Support for interpolatable properties.
- [ ] Optional: Anti Aliasing
- [ ] Text-Atlas: Currently I render one texture per character per font per font_size used. Using a single Atlas would allow me to avoid most of the memory throughput overhead. (Instancing is implemented, but Atlas is still missing)
- [x] Text Glyphs should be rendered at certain breakpoints like 8pt, 16pt, 32pt etc. When drawing a glyph we should pick an appropriate one and then rescale it via sampling on the gpu. (We would have to recreate every glyph / atlas when font_size is animated for every frame)
- [ ] Rich Text. Color, Font, Size, Clickable, Hoverable, (embedded ui elements?)
- [ ] Web and Native colors don't match. One of them does not compensate for sRGB correctly.
- [ ] Audio Engine
- [x] Resource / File loading (Web vs Native)

.General Framework TODOs
- [ ] Improved Input System: Better handling of multi-key combos and gamepad support.
- [ ] Localization Support: Framework-level support for translated strings.
- [ ] Documentation: Move from basic READMEs to comprehensive documentation.
- [ ] Testing: Implement automated UI and rendering tests.